---
title: "Re: ソフトウェアを完成させる"
date: 2022-09-15T22:03:55-07:00
---
「ソフトウェアを完成させる」話はよく読まれたので、ちょっと続き。前回の話では、いくつかの話が一緒になっていたので、Twitter やはてなブックマークで見かけた話も含めて、分けて考えてみる。

GUI のはなし。私は最近の GUI の変化をあんまり好ましく思っていない。Windows 95 とか NeXTSTEP とか BeOS あたりが一つの完成形で、スキューモーフィズムはやりすぎだったし、フラットデザインは見た目のキュー (これが押せますよ) がなさすぎるんじゃないか。アイコンの多用とか、スクロールしていないときは消えるスクロールバーとかも、スマートフォンのような狭い画面だったら意味があったものが、意匠として外に輸出されすぎていると思う。ただ、GUI は専門ではないので、この話はあまり深掘りできない。

役割分担のはなし。2022年に log4j とかをみると、なんか色々やっているなあと思う。ログに関しては、12 Factor App やコンテナ、あるいは systemd でも、アプリケーションはただバイト列を吐いて、それをディスクに書いたり、外の世界に持ち出すのは、アプリケーションの仕事ではない、というのが主流になりつつある。あるいは、パブリッククラウドでも、EC2 インスタンス、コンテナ、関数 (Lambda みたいなやつ) と並べると、どんどんユーザーが責任をもってアップグレードしたりする範囲が減っている。他の分野でも分担を変えられるところはあるだろうか。

セキュリティのはなし。コンシューマ向けのアプリケーションでは「カメラを使ってもいいですか」みたいな権限を尋ねるのが普通になって平和になってきたし、Linux だとプロセス単位のケイパビリティをつけられる。プログラミング言語も安全になってきた (C/C++ で書かなくてはいけないものが減ってきた) し、安全なソフトウェアを書くのはやりやすくなってきた。

再現性のはなし。C と共有ライブラリの時代には、あるライブラリに脆弱性があったら、それをアップグレードしておわり、ということができた。いまだと、go.mod とか、ベースのコンテナイメージをアップグレードしなくてはいけなくて、めちゃくちゃ困るわけではないけど、ちょっと面倒くさい。ソフトウェアの再現性を保つためには便利だけど、それと引き換えに、交換可能なものをくっつけているきらいはある。Linux ディストリビューションのユーザーランドをアプリケーションとくっつけて配布するとか、考えると結構な力技だ。

こうやって色々列挙すると、それなりに新しいものにふれないといけないのが「完成」の難しさというか、毎年の変化にも意味はあるんですよ、というのを示しているとも思う。2005年だったら、例えば Rust は個人プロジェクトですらないし、CAP_BPF もないわけで。でも、もうちょっと壊れないでいてほしいというか、プログラマがぽちぽち直してくのは、結局「運用でカバー」よなあ。
